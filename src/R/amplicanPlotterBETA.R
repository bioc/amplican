# This function takes a configuration file and generate the alignments.
#
# Parameters:
#
# (string) ANALYSIS_PATH  The path to an alignment folder generated by
#                         ampliCanAnalyzer(). For example:
#
#                           /Home/johndoe/.../run_20150420171327_run11/Analysis_3_5_TRUE_TRUE_10_20150511142938
#
# (int) TOTAL_PROCESSORS  Set this to the number of processors you want to use.
#                         You can set it to NULL if you want all that are
#                         available. Default = 1.
#
# (int) SELECTED_THEME    Which Theme do you want for the plots
#                         1: Default theme (this is the default option)
#                         2: Colorblind
#                         3: Greyscale
#                         
#                         User define: Select any valid option, 1,2, or 3. This
#                         will be your default base colors. You can modify the
#                         colors in the following parameters. If you don't
#                         expecify one color, by default the option you choose
#                         will be use. If you don't specify a valid option,
#                         option 1 will be use.
#
# (string) CUT_RATE       Color code for the cut sequences in the cut rate plot
#                         A string starting with '#' and 6 hex digit
#                         representing a RGB color. For example: "#00bfc4"
#                         Default option is NULL.
#
# (string) NO_CUT_RATE    Color code for those sequences that are not cut in
#                         the cut rate plot. A string starting with '#' and 6
#                         hex digit representing a RGB color.
#                         For example: "#00bfc4". Default option is NULL.
#
# (string) NO_DELETION    Color code for those sequences with no deletions in
#                         the frameshift plot. A string starting with '#' and 6
#                         hex digit representing a RGB color.
#                         For example: "#00bfc4". Default option is NULL.
#
# (string) IN_FRAME       Color code for those sequences with deletions within
#                         3 nucleotide frame in the frameshift plot. A string
#                         starting with '#' and 6 hex digit representing a RGB
#                         color. For example: "#00bfc4". Default option is NULL
#
# (string) FRAMESHIFT     Color code for those sequences with deletions out of
#                         frame in the frameshift plot. A string starting with
#                         '#' and 6 hex digit representing a RGB color. For
#                         example: "#00bfc4". Default option is NULL.
#
# (string) MULTIPLES      Color code for those sequences with several deletions
#                         in the frameshift plot. A string starting with '#'
#                         and 6 hex digit representing a RGB color. For
#                         example: "#00bfc4". Default option is NULL.
#
# (string) DELETION_COLOR Color code for those archs that represent a deletion
#                         in the archplot. A string starting with '#'
#                         and 6 hex digit representing a RGB color. For
#                         example: "#00bfc4". Default option is NULL.
#
# (string) CUT_COLOR      Color code for those archs that represent a cut
#                         in the archplot. A string starting with '#'
#                         and 6 hex digit representing a RGB color. For
#                         example: "#00bfc4". Default option is NULL.
#
# (string) POSITION_WINDOW Color code for the AP square in the archplot. A
#                          string starting with '#' and 6 hex digit
#                          representing a RGB color. For example: "#00bfc4".
#                          Default option is NULL.
#
# (string) START          Color for the left line that represent the start
#                         position of the amplicon in the archplot. A string
#                         starting with '#' and 6 hex digit representing a RGB
#                         color. For example: "#00bfc4". Default option is NULL
#
# (string) END            Color for the right line that represent the end
#                         position of the amplicon in the archplot. A string
#                         starting with '#' and 6 hex digit representing a RGB
#                         color. For example: "#00bfc4". Default option is NULL
#
# (bool) FREQONE          The archplot can be all be normalized between -1 to 1
#                         or be "zoom in" between their respective maximum and
#                         minimum frequency (which will be more closer to 0
#                         than -1 and 1). If you want it to be between -1 and 1
#                         always, set this variable to TRUE. Default is TRUE.
#
# (bool) ACCUMULATE       The archs in the archplots can represent one sequence
#                         each, or we can accumulate all the events that have
#                         the same start and end at the same interval. If you
#                         want to accumulate the height of the archs, set this
#                         variable to TRUE. But if you want each arch to
#                         represent each sequence independently, set this to
#                         FALSE. Default is TRUE.
#
# (bool) FILTERENDS       You can filter start and end deletions. Usually you
#                         will get a lot of deletions that start at 1 and ends
#                         at the end of the amplicon, that are there because
#                         the sequences are just short and that part don't
#                         alignt with anything. If you want to do that set this
#                         variable to TRUE. Otherwise set it to FALSE. This
#                         will skip all deletions (not cuts) that start at 1
#                         and all deletions that end at length(amplicon).
#                         Default is FALSE.
#
# (string) NOASSIGNED     Color for the sequences that are not assigned to a
#                         barcode in the barcode plot. A string starting with
#                         '#' and 6 hex digit representing a RGB color. For
#                         example: "#00bfc4". Default option is NULL.
#
# (string) SEQUENCE       Color for the sequences that are assigned to a
#                         barcode in the barcode plot. A string starting with
#                         '#' and 6 hex digit representing a RGB color. For
#                         example: "#00bfc4". Default option is NULL.
#
# (string) READ           Color for the sequences that are not assigned to a
#                         barcode, AND have also valid cuts, in the barcode
#                         plot. A string starting with '#' and 6 hex digit
#                         representing a RGB color. For example: "#00bfc4".
#                         Default option is NULL.
#
# (string) PASS           Color for the sequences that passed all the initial
#                         filters, like bad N nucleotides, low quality and so
#                         on. For the filters plot. A string starting with '#'
#                         and 6 hex digit representing a RGB color. For
#                         example: "#00bfc4". Default option is NULL.
#
# (string) FAILED         Color for the sequences that didn't passed all the
#                         initial filters, like bad N nucleotides, low quality
#                         and so on. For the filters plot. A string starting
#                         with '#' and 6 hex digit representing a RGB color.
#                         For example: "#00bfc4". Default option is NULL.
#
# (string) PLOTBACK       Color for the backpanel of the plots. A string
#                         starting with '#' and 6 hex digit representing a RGB
#                         color. For example: "#00bfc4".
#                         Default option "#FFFFFF"
#
# (string) PLOTGRID       Color for the grid lines of the plots. A string
#                         starting with '#' and 6 hex digit representing a RGB
#                         color. For example: "#00bfc4".
#                         Default option "#888888"
#
# (string) LINETYPE       Type of lines for the grid in the plots. There are
#                         several options for this. Please refer to the ggplot2
#                         documentation for values for "linetype"; in here we
#                         some of the options
#                         "blank", "solid", "dashed", "dotted" (Default),
#                         "dotdash", "longdash", "twodash", "1F", "F1",
#                         "4C88C488", "12345678".
#
# (bool) DUPLICATE_INTO_FOLDERS The plots are going to be group into a single
#                               folder. Beside that, you can duplicate each of
#                               the archplots and the histogram plots into each
#                               of the individual folders that compose the
#                               analysis. Default is FALSE.
#
# (string) FORMAT         You can choose the format of the output images.
#                         Please refer to the ggplot2 documentation for
#                         "ggsave". In here we list some of the options:
#                         "jpg", "png" (default), "svg", "pdf", "bmp".
#
# (string) SIZE           Archplots and mutations plots are images which width
#                         iss desproportional to anything else. The image size
#                         is quite complex as it involve several variables to
#                         draw nicelly text, bars, and many things. In here
#                         you can select one of the preselected sizes for your
#                         images. NOTE: The size vary almost nothing the time
#                         its takes to draw and save the image.
#
#                         Please use one of this preselected sizes:
#                         "4K"   - 11811 x 2100 - 1000x178 mm² (Default)
#                         "1080" - 6075  x 1080 - mm²
#                         "720"  - 4050  x 720  - mm²
#                         "VGA"  - 3038  x 480  - mm²
#
# (int) GROUPBY           For barcode plots, filter plots, frameshift plots,
#                         and cut rate plots, you can choose to draw several
#                         config file rows at the same plot. In order to do
#                         that, set this number to something bigger than 1.
#                         The highgest the number, the more rows will be group
#                         toguether. Default is 20.
#
# (bool) TIMING           You can choose to generate a timing file for
#                         debugging and benchmarking. Default is FALSE.


ampliCanPlotter <- function (ANALYSIS_PATH, TOTAL_PROCESSORS = 1,
                             SELECTED_THEME = 1, CUT_RATE = NULL,
                             NO_CUT_RATE = NULL, NO_DELETION = NULL,
                             IN_FRAME = NULL, FRAMESHIFT = NULL,
                             MULTIPLES = NULL, DELETION_COLOR = NULL,
                             CUT_COLOR = NULL, POSITION_WINDOW = NULL,
                             START = NULL, END = NULL, FREQONE = TRUE,
                             ACCUMULATE = TRUE, FILTERENDS = FALSE,
                             NOASSIGNED = NULL, SEQUENCE = NULL,
                             READ = NULL, PASS = NULL, FAILED = NULL,
                             PLOTBACK = "#FFFFFF", PLOTGRID = "#888888",
                             LINETYPE = "dotted",
                             DUPLICATE_INTO_FOLDERS = FALSE, FORMAT = "png",
                             SIZE = "4K", GROUPBY = 20, TIMING = FALSE){

  # Default Colors configuration
  
  # Colors for the cut rates plots
  CUT_RATE_DEFAULTS    <- c("#00bfc4","#66CC33", "#AAAAAA") 
  NO_CUT_RATE_DEFAULTS <- c("#f8766d","#000099", "#333333") 
  
  # Colors for the frameshift plot
  NO_DELETION_DEFAULTS <- c("#999999","#000099", "#111111") 
  IN_FRAME_DEFAULTS    <- c("#f5ff70","#000000", "#777777") 
  FRAMESHIFT_DEFAULTS  <- c("#70ff9d","#66CC33", "#FFFFFF") 
  MULTIPLES_DEFAULTS   <- c("#ff70ca","#FFFFFF", "#CCCCCC") 
  
  # Colors for the archplots
  DELETION_COLOR_DEFAULTS   <- c("#CC0000","#000099", "#333333") 
  CUT_COLOR_DEFAULTS        <- c("#66CC33","#66CC33", "#AAAAAA") 
  POSITION_WINDOW_DEFAULTS  <- c("#3399FF","#FFFFFF", "#000000")
  START_DEFAULTS            <- c("#00FF00","#9900CC", "#000000")
  END_DEFAULTS              <- c("#00FF00","#9900CC", "#000000")
  
  # Colors for the barcodes plots
  NOASSIGNED_DEFAULTS <- c("#999999","#000000", "#111111")
  SEQUENCE_DEFAULTS   <- c("#f8766d","#000099", "#333333")
  READ_DEFAULTS       <- c("#00bfc4","#66CC33", "#AAAAAA")
  
  # Colors for the filters plots
  PASS_DEFAULTS       <- c("#7FDF52","#FFFFFF", "#FFFFFF")
  FAILED_DEFAULTS     <- c("#000000","#000000", "#000000")
  
  
  
  # Selecting the final colors
  
  # First, addjust the selected theme for a valid option
  if(SELECTED_THEME>3 || SELECTED_THEME<1){ SELECTED_THEME <- 1}
  
  # Now, if the users selected something else from NULL for the colors, use that.
  # But if something is null, set the constant to the selected theme
  if(is.null(CUT_RATE)){ CUT_RATE <- CUT_RATE_DEFAULTS[SELECTED_THEME]}
  if(is.null(NO_CUT_RATE)){ NO_CUT_RATE <- NO_CUT_RATE_DEFAULTS[SELECTED_THEME]}
  if(is.null(NO_DELETION)){ NO_DELETION <- NO_DELETION_DEFAULTS[SELECTED_THEME]} 
  if(is.null(IN_FRAME)){ IN_FRAME<- IN_FRAME_DEFAULTS[SELECTED_THEME]} 
  if(is.null(FRAMESHIFT)){ FRAMESHIFT <- FRAMESHIFT_DEFAULTS[SELECTED_THEME]} 
  if(is.null(MULTIPLES)){ MULTIPLES <- MULTIPLES_DEFAULTS[SELECTED_THEME]} 
  if(is.null(DELETION_COLOR)){ DELETION_COLOR <- DELETION_COLOR_DEFAULTS[SELECTED_THEME]} 
  if(is.null(CUT_COLOR)){ CUT_COLOR <- CUT_COLOR_DEFAULTS[SELECTED_THEME]} 
  if(is.null(POSITION_WINDOW)){ POSITION_WINDOW <- POSITION_WINDOW_DEFAULTS[SELECTED_THEME]} 
  if(is.null(START)){ START <- START_DEFAULTS[SELECTED_THEME]} 
  if(is.null(END)){ END <- END_DEFAULTS[SELECTED_THEME]} 
  if(is.null(NOASSIGNED)){ NOASSIGNED <- NOASSIGNED_DEFAULTS[SELECTED_THEME]} 
  if(is.null(SEQUENCE)){ SEQUENCE <- SEQUENCE_DEFAULTS[SELECTED_THEME]} 
  if(is.null(READ)){ READ <- READ_DEFAULTS[SELECTED_THEME]} 
  if(is.null(PASS)){ PASS <- PASS_DEFAULTS[SELECTED_THEME]} 
  if(is.null(FAILED)){ FAILED <- FAILED_DEFAULTS[SELECTED_THEME]}
  #if(is.null()){  <- _DEFAULTS[SELECTED_THEME]} 
  
  ############################################
  #Summons the libraries and get to use functions from there.
  ############################################
  {
  
  # Plotting stuff
  library(reshape2) # Rearrenge data for ggplot
  library(ggplot2) 
  library(GenomicRanges) # For the archplots
  library(ggbio)
  
  # Making things in parallel
  library(doParallel) 
  cl <- makeCluster(TOTAL_PROCESSORS, outfile="") #outfile tells the workers to print on the terminal
  registerDoParallel(cl)
  
  # Our own developed stuff.
  source("libraries/tools.R") # Minor stuff like the reverse complement of a DNA sequence.
  source("libraries/configPlotting.R") # Function that deals with the config files and get running everything.
  
  }
  
  ############################################
  # Algorith starts here
  ############################################
  
  print("START")
  
  # We are going to write the results in the same folder, inside another folder called:
  # Plot_<plot variables>_YYYYmmddHHMMSS
  {
      # Creates the folder for the plots
      currentTime <- Sys.time()
      timeStamp   <- strftime(currentTime,"%Y%m%d%H%M%S")
      plotPath    <- paste(ANALYSIS_PATH, "/Plots_",SELECTED_THEME,"_",FORMAT,"_",timeStamp, sep = '')
      
      dir.create(file.path(plotPath), showWarnings = TRUE)
      
      # Findout relevant variables from the analysis.
      # -- We need to know the alignment distance in order to plot the AP plust the window properly.
      alignmentDistance <- 5 # Initialize to some default value (we don't really need to do this)
      
      # -- Get the path with the relevant file
      analysisLogPath      <- list.files(path = ANALYSIS_PATH, pattern="AnalysisLog.txt", full.names = TRUE)
      
      # -- Inside that file, look for this line: "ALIGNMENT DISTANCE    :  5" and read the number
      textLogFile <- readLines(analysisLogPath,encoding="UTF-8")
      alignmentDistance <- as.numeric(strsplit(textLogFile[3], ":")[[1]][2])
      
      
      # Creates a folder for all the data that is shown in the plots
      dataPath   <- paste(plotPath,"/Data",sep='',collapse='')
      dir.create(file.path(dataPath), showWarnings = TRUE)
      
      # Inside this folder it will be a file named log where we will write relevant information
      logFileName <- paste(plotPath, "/PlotsLog.txt", sep = '')
      logFileConn <- file(logFileName, open="w")
      
      # Write the analysis variables into the log
      writeLines("The plot was made with the following variables: ", logFileConn)
      writeLines(" -- Cut Rate -- ", logFileConn)
      writeLines(paste("CUT_RATE           : ", CUT_RATE), logFileConn)
      writeLines(paste("NO_CUT_RATE        : ", NO_CUT_RATE), logFileConn)
      writeLines(" -- Arch plot -- ", logFileConn)
      writeLines(paste("DELETION_COLOR     : ", DELETION_COLOR), logFileConn)
      writeLines(paste("CUT_COLOR          : ", CUT_COLOR), logFileConn)
      writeLines(paste("POSITION_WINDOW    : ", POSITION_WINDOW), logFileConn)
      writeLines(paste("START              : ", START), logFileConn)
      writeLines(paste("END                : ", END), logFileConn)
      writeLines(" -- Others -- ", logFileConn)
      writeLines(paste("DUPLICATE_INTO_FOLDERS : ", DUPLICATE_INTO_FOLDERS), logFileConn)  
      writeLines(paste("GROUP BY               : ", GROUPBY), logFileConn)  
      writeLines("", logFileConn) # Empty line
      
      # Find out where is the alignments, we need to get some data from there.
      analysisTree        <- strsplit(ANALYSIS_PATH, "/", fixed = TRUE)[[1]]
      analysisTreeDeep    <- length(analysisTree)
      alignmentTree       <- analysisTree[1:analysisTreeDeep -1]
      ALIGNMENTFOLDER     <- paste(alignmentTree, collapse='/')
      ALIGNMENTFOLDER     <- list.files(path = ALIGNMENTFOLDER, pattern = "_alignments", full.names = TRUE)  
      UNNASIGNEDFILES     <- list.files(path = paste(ALIGNMENTFOLDER,"/unassigned_sequences",sep='',collapse=''), full.names = TRUE)
      
    }

  # Read the config file from the analysis folder and get the ID+Barcode and Cut Rate
  analysisDF <-  read.table(paste(ANALYSIS_PATH, "/analysis_results.txt", sep=''), header=TRUE, sep="\t")

  #----------------------------
  # --- CUT RATE PLOT (Both normalize and absolute)
  #----------------------------
    {
      
      print("Plotting Cut Rates")
      
      keeps <- c("ID","Barcode", "Cut_Rate")
      cutRateDF <- analysisDF[keeps]
      cutRateDF <- cutRateDF[ order(as.numeric(row.names(cutRateDF))), ]
      cutRateDF$Complement <- 1 - cutRateDF$Cut_Rate
      
      cutRateDF$ID_Barcode <- paste(cutRateDF$ID,"_",cutRateDF$Barcode,sep='')
      
      subCutRatesDF   <- split(cutRateDF, factor(sort(rank(row.names(cutRateDF))%%ceiling(nrow(cutRateDF)/GROUPBY))))
      
      # We are plotting cut rates in groups of 20 (default)
      # If we happen to have a lot of rows we will create an enourmous image
      
      for (j in 1:length(subCutRatesDF)){
        
        cutRateDF <- subCutRatesDF[[j]][,c("ID_Barcode","Cut_Rate","Complement")]
        
        # If all the data for the complement and the Cut Rate is NA, the ggplot will fail.
        # We need to make sure that at least one is 0
        if(is.na(cutRateDF$Complement[1])){
          cutRateDF$Complement[1] <- 0  
        }
        
        colnames(cutRateDF) <- c("ID_Barcode", "Cut Reads", "Not Cut")
        
        cutRateDFMelted <- melt( cutRateDF , id.var="ID_Barcode")
        colnames(cutRateDFMelted) <- c("ID_Barcode","variable", "Relative")
        
        ggplot(cutRateDFMelted, aes(x = ID_Barcode, y = Relative, fill = variable)) +
          geom_bar(stat = "identity", colour="black") +
          scale_fill_manual(values=c(CUT_RATE, NO_CUT_RATE)) +
          theme(axis.text.x = element_text(angle = 90, hjust = 1),
                panel.background = element_rect(fill = PLOTBACK),
                panel.grid.major = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.2),
                panel.grid.minor = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.5),
                panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank())
        
        ggsave(paste(plotPath,"/Cut_Rates_",j,".", FORMAT ,sep = ''),width= nrow(subCutRatesDF[[j]]) * GROUPBY , units="mm", limitsize=FALSE)
        
        
        fileName <- paste(dataPath,"/Cut_Rates_",j,".txt",sep = '', collapse = '')
        write.table(cutRateDFMelted, file = fileName, quote = FALSE, sep = "\t")
        
      }
      
      keeps <- c("ID", "Barcode", "Sum_Is_Sequence", "Sum_Is_Read")
      cutRateAbsoluteDF <- analysisDF[keeps]
      
      cutRateAbsoluteDF <- cutRateAbsoluteDF[ order(as.numeric(row.names(cutRateAbsoluteDF))), ]
      cutRateAbsoluteDF$Sum_Is_Sequence <- cutRateAbsoluteDF$Sum_Is_Sequence - cutRateAbsoluteDF$Sum_Is_Read
      cutRateAbsoluteDF$ID_Barcode <- paste(cutRateAbsoluteDF$ID,"_",cutRateAbsoluteDF$Barcode,sep='')
      subCutRatesAbsoluteDF   <- split(cutRateAbsoluteDF, factor(sort(rank(row.names(cutRateAbsoluteDF))%%ceiling(nrow(cutRateAbsoluteDF)/GROUPBY))))
      
      
      for (j in 1:length(subCutRatesAbsoluteDF)){
        
        cutRateAbsoluteDF <- subCutRatesAbsoluteDF[[j]][,c("ID_Barcode","Sum_Is_Read","Sum_Is_Sequence")]
        colnames(cutRateAbsoluteDF) <- c("ID_Barcode", "Cut Reads", "Not Cut")
        
        cutRateAbsoluteDFMelted <- melt( cutRateAbsoluteDF , id.var="ID_Barcode")
        colnames(cutRateAbsoluteDFMelted) <- c("ID_Barcode","variable", "Reads")
        
        ggplot(cutRateAbsoluteDFMelted, aes(x = ID_Barcode, y = Reads, fill = variable)) +
          geom_bar(stat = "identity", colour="black") +
          scale_fill_manual(values=c(CUT_RATE, NO_CUT_RATE)) +
          theme(axis.text.x = element_text(angle = 90, hjust = 1),
                panel.background = element_rect(fill = PLOTBACK),
                panel.grid.major = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.2),
                panel.grid.minor = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.5),
                panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank())
        
        ggsave(paste(plotPath,"/Cut_Rates_Absolute_",j,".", FORMAT ,sep = ''),width= nrow(subCutRatesDF[[j]]) * GROUPBY , units="mm", limitsize=FALSE)
        
        fileName <- paste(dataPath,"/Cut_Rates_Absolute_",j,".txt",sep = '', collapse = '')
        write.table(cutRateAbsoluteDFMelted, file = fileName, quote = FALSE, sep = "\t")
        
      }
      
      
    }

  #----------------------------
  # --- FRAMESHIFT PLOT
  #----------------------------
    {
      
      print("Plotting Frameshifts")
      
      # Now; lets make the in-frame and frameshift statistics.
      frameShiftTable <- analysisDF[,c("ID","Barcode",
                                       "Sum_Is_Sequence",
                                       "Forward_No_Deletions","Forward_In_Frameshift",
                                       "Forward_Out_Frameshift","Forward_Multiple_Deletions",
                                       "Sum_Is_Read",
                                       "Forward_Read_No_Deletions","Forward_Read_In_Frameshift",
                                       "Forward_Read_Out_Frameshift","Forward_Read_Multiple_Deletions")]
  
      # Order by row ID
      frameShiftTable <- frameShiftTable[ order(as.numeric(row.names(frameShiftTable))), ]
      
      # Get the percentage for the frameshift of ALL deletions
      frameShiftTable$Percentage_No_Deletion   <- frameShiftTable$Forward_No_Deletions / frameShiftTable$Sum_Is_Sequence
      frameShiftTable$Percentage_In_Frameshift <- frameShiftTable$Forward_In_Frameshift / frameShiftTable$Sum_Is_Sequence
      frameShiftTable$Percentage_Out_Frameshift <- frameShiftTable$Forward_Out_Frameshift / frameShiftTable$Sum_Is_Sequence
      frameShiftTable$Percentage_Multiple_Deletions <- frameShiftTable$Forward_Multiple_Deletions / frameShiftTable$Sum_Is_Sequence
      
      # Get the percentage for the frameshift of ONLY valid deletions
      frameShiftTable$Percentage_Reads_No_Deletion   <- frameShiftTable$Forward_Read_No_Deletions / frameShiftTable$Sum_Is_Read
      frameShiftTable$Percentage_Reads_In_Frameshift <- frameShiftTable$Forward_Read_In_Frameshift / frameShiftTable$Sum_Is_Read
      frameShiftTable$Percentage_Reads_Out_Frameshift <- frameShiftTable$Forward_Read_Out_Frameshift / frameShiftTable$Sum_Is_Read
      frameShiftTable$Percentage_Reads_Multiple_Deletions <- frameShiftTable$Forward_Read_Multiple_Deletions / frameShiftTable$Sum_Is_Read
  
      frameShiftTable$ID_Barcode <- paste(frameShiftTable$ID,"_",frameShiftTable$Barcode,sep='')
      
      subframeShiftDF <- split(frameShiftTable, factor(sort(rank(row.names(frameShiftTable))%%ceiling(nrow(frameShiftTable)/GROUPBY))))
  
      # Once more, we try to avoid very wide bar plots
      for (j in 1:length(subframeShiftDF)){
        
        # FRAMESHIFT FOR ALL THE SEQUENCES
        # ---------------------------------
        {
      
        frameshiftDF <- subframeShiftDF[[j]][,c("ID_Barcode","Percentage_No_Deletion",
                                                "Percentage_In_Frameshift","Percentage_Out_Frameshift",
                                                "Percentage_Multiple_Deletions")]
        
        # If all the data for the percentages is NA or NaN
        # We need to make sure that at least one is 0
        if(is.nan(frameshiftDF$Percentage_No_Deletion[1])){
          frameshiftDF$Percentage_No_Deletion[1]        <- 0
          frameshiftDF$Percentage_In_Frameshift[1]      <- 0
          frameshiftDF$Percentage_Out_Frameshift[1]     <- 0
          frameshiftDF$Percentage_Multiple_Deletions[1] <- 0
        }
      
        colnames(frameshiftDF) <- c("ID_Barcode","No Deletion","Preserve Frame","Frameshift","Multiple Deletions")
      
        # Reorder so the frameshift is at the botoom of the plot
        frameshiftDF <- frameshiftDF[c("ID_Barcode", "Frameshift", "Preserve Frame", "Multiple Deletions", "No Deletion" )]
        
        frameShiftTableMelted <- melt(frameshiftDF, id.var="ID_Barcode")
        colnames(frameShiftTableMelted) <- c("ID_Barcode","variable", "Frequency_Relative")
      
        #labels <- frameShiftTable$ID_Barcode
        ggplot(frameShiftTableMelted, aes(x = ID_Barcode, y = Frequency_Relative, fill = variable)) +
          geom_bar(stat = "identity", colour="black") +
          scale_fill_manual(values=c(FRAMESHIFT, IN_FRAME, MULTIPLES, NO_DELETION)) +
          theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "right", 
                panel.background = element_rect(fill = PLOTBACK),
                panel.grid.major = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.2),
                panel.grid.minor = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.5),
                panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank())
        
        ggsave(paste(plotPath,"/Frameshift_",j,".", FORMAT ,sep = ''),
               width= nrow(subframeShiftDF[[j]]) * GROUPBY,
               units="mm", limitsize=FALSE)
      
        fileName <- paste(dataPath,"/Frameshift_",j,".txt",sep = '', collapse = '')
        write.table(frameShiftTableMelted, file = fileName, quote = FALSE, sep = "\t")
      
        }
    
        # FRAMESHIFT ONLY FOR READS
        # ---------------------------------
        {
      
        frameshiftReadsDF <- subframeShiftDF[[j]][,c("ID_Barcode","Percentage_Reads_No_Deletion",
                                                     "Percentage_Reads_In_Frameshift","Percentage_Reads_Out_Frameshift",
                                                     "Percentage_Reads_Multiple_Deletions")]
          
        # If all the data for the percentages is NA or NaN
        # We need to make sure that at least one is 0
        if(is.nan(frameshiftReadsDF$Percentage_Reads_No_Deletion[1])){
          frameshiftReadsDF$Percentage_Reads_No_Deletion[1]        <- 0
          frameshiftReadsDF$Percentage_Reads_In_Frameshift[1]      <- 0
          frameshiftReadsDF$Percentage_Reads_Out_Frameshift[1]     <- 0
          frameshiftReadsDF$Percentage_Reads_Multiple_Deletions[1] <- 0
        }
      
        # Change columns names so they are more recognizable
        colnames(frameshiftReadsDF) <- c("ID_Barcode", "No Deletion", "Preserve Frame",
                                         "Frameshift", "Multiple Deletions")
      
        # Reorder so the frameshift is at the botoom of the plot
        frameshiftReadsDF <- frameshiftReadsDF[c("ID_Barcode", "Frameshift", "Preserve Frame",
                                                 "Multiple Deletions", "No Deletion")]
      
        frameShiftTableMelted <- melt(frameshiftReadsDF, id.var="ID_Barcode")
        colnames(frameShiftTableMelted) <- c("ID_Barcode","variable", "Frequency_Relative")
      
        #labels <- frameShiftTable$ID_Barcode
        ggplot(frameShiftTableMelted, aes(x = ID_Barcode, y = Frequency_Relative, fill = variable)) +
          geom_bar(stat = "identity", colour="black") +
          scale_fill_manual(values=c(FRAMESHIFT, IN_FRAME, MULTIPLES, NO_DELETION)) +
          theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "right",
              panel.background = element_rect(fill = PLOTBACK),
              panel.grid.major = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.2),
              panel.grid.minor = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.5),
              panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank())
      
        ggsave(paste(plotPath,"/Frameshift_ReadsOnly_",j,".", FORMAT ,sep = ''),
               width= nrow(subframeShiftDF[[j]]) * GROUPBY,
               units="mm", limitsize=FALSE)
      
        fileName <- paste(dataPath,"/Frameshift_ReadsOnly",j,".txt",sep = '', collapse = '')
        write.table(frameShiftTableMelted, file = fileName, quote = FALSE, sep = "\t")
      }
    
      }

    }

  #----------------------------
  # --- BARCODE PLOT
  #----------------------------
    {
  
    print("Plotting Barcodes Info")
    
    #Make the barcode dataframe
    barcodeDF <-  read.table(paste(ALIGNMENTFOLDER, "/barcodeFile_results.txt", sep=''), header=TRUE, sep="\t")
    uniqueBarcodes <- barcodeDF$Barcode
    
    # -- Prepare the final dataframe where everything goes
    barcodeTableFinal=data.frame(matrix(NA, nrow=length(uniqueBarcodes), ncol=9))
    names(barcodeTableFinal) <- c("Barcode","Total_Pre_N_Filter","Total_Post_N_Filter",
                                  "Failed_N_Filter","Experiment_Unique_Sequences",
                                  "Barcode_Total_Sequences",
                                  "Barcode_Total_Reads",
                                  "Barcode_Unnasigned","Barcode_non_read")
  
    # -- For each of those barcodes
    for(j in 1:length(uniqueBarcodes)){
      
      #Make a subset with that barcode (keep the barcode row)
      barcodeSubset <- subset(barcodeDF, Barcode == uniqueBarcodes[j])
      
      #Make a subset with that barcode ID from the analysis (might be several)
      analysisSubset <- subset(analysisDF, Barcode == uniqueBarcodes[j])
      
      #Update the rest of the columns in the new dataframe
      barcodeTableFinal$Barcode[j] <- toString(uniqueBarcodes[j])
      barcodeTableFinal$Total_Pre_N_Filter[j] <- barcodeSubset$Total_Pre_N_Filter[1]
      barcodeTableFinal$Total_Post_N_Filter[j] <- barcodeSubset$Total_Post_N_Filter[1]
      barcodeTableFinal$Experiment_Unique_Sequences[j] <- barcodeSubset$Experiment_Unique_Sequences[1]
    
      barcodeTableFinal$Barcode_Total_Sequences[j] <- sum(analysisSubset$Sum_Is_Sequence)
      barcodeTableFinal$Barcode_Total_Reads[j]     <- sum(analysisSubset$Sum_Is_Read)
      
      # These columns are just a combination of the previous ones, but we need it for melting the data later
      barcodeTableFinal$Failed_N_Filter[j]    <- barcodeSubset$Total_Pre_N_Filter[1]  - barcodeSubset$Total_Post_N_Filter[1]
      barcodeTableFinal$Barcode_Unnasigned[j] <- barcodeSubset$Total_Post_N_Filter[1] - barcodeTableFinal$Barcode_Total_Sequences[j]
      barcodeTableFinal$Barcode_non_read[j]   <- barcodeTableFinal$Barcode_Total_Sequences[j] - barcodeTableFinal$Barcode_Total_Reads[j]
      
    }
  
    # Get the data we need for each of the plot
    barcodeAssignedData <- subset(barcodeTableFinal, select=c(Barcode,Barcode_Unnasigned,Barcode_non_read,Barcode_Total_Reads))
    barcodeFilterData   <- subset(barcodeTableFinal, select=c(Barcode,Failed_N_Filter,Total_Post_N_Filter))
    
    barcodeAssignedData <- barcodeAssignedData[ order(as.numeric(row.names(barcodeAssignedData))), ]
    barcodeFilterData   <- barcodeFilterData[   order(as.numeric(row.names(barcodeFilterData)))  , ]
    
    # Change the names of the columns for human users
    colnames(barcodeAssignedData) <- c("Barcode", "Unnasigned", "No cut", "Cut Read")
    colnames(barcodeFilterData)   <- c("Barcode", "Failed"    , "Pass")
    
    # Reorder so the important things are at the bottom of the plot  
    barcodeAssignedData <- barcodeAssignedData[c("Barcode", "Cut Read", "No cut", "Unnasigned")]
    barcodeFilterData   <- barcodeFilterData[  c("Barcode", "Pass"    , "Failed")]
  
    # Divide for the assigned barcodes
    subBarcodeAssignedDF <- split(barcodeAssignedData, factor(sort(rank(as.numeric(row.names(barcodeAssignedData)))%%ceiling(nrow(barcodeAssignedData)/GROUPBY))))
  
    for (j in 1:length(subBarcodeAssignedDF)){
      
      barcodeAssignedMelted <- melt(subBarcodeAssignedDF[[j]], id.var="Barcode")
      
      ggplot(barcodeAssignedMelted, aes(x = Barcode, y = value, fill = variable)) +
        geom_bar(stat = "identity", colour="black") +
        scale_fill_manual(values=c(READ, SEQUENCE, NOASSIGNED)) +
        theme(axis.text.x = element_text(angle = 90, hjust = 1),
              panel.background = element_rect(fill = PLOTBACK),
              panel.grid.major = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.2),
              panel.grid.minor = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.5),
              panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank())
      
      ggsave(paste(plotPath,"/barcode_assigned_",j,".",FORMAT ,sep = ''),
             width= (nrow(subBarcodeAssignedDF[[j]]) * GROUPBY) + 50 , units="mm", limitsize=FALSE)
      
      fileName <- paste(dataPath,"/barcode_assigned_",j,".txt",sep = '', collapse = '')
      write.table(barcodeAssignedMelted, file = fileName, quote = FALSE, sep = "\t")
      
    }
  
    # Divide for the filters
    subBarcodeFiltersDF <- split(barcodeFilterData, factor(sort(rank(as.numeric(row.names(barcodeFilterData)))%%ceiling(nrow(barcodeFilterData)/GROUPBY))))
  
    for (j in 1:length(subBarcodeAssignedDF)){
      
      barcodeFilterMelted <- melt(subBarcodeFiltersDF[[j]], id.var="Barcode")
      
      ggplot(barcodeFilterMelted, aes(x = Barcode, y = value, fill = variable)) +
        geom_bar(stat = "identity", colour="black") +
        scale_fill_manual(values=c(PASS, FAILED)) +
        theme(axis.text.x = element_text(angle = 90, hjust = 1), panel.background = element_rect(fill = PLOTBACK),
              panel.grid.major = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.2),
              panel.grid.minor = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.5),
              panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank())
      
      ggsave(paste(plotPath,"/barcode_filters_",j,".",FORMAT ,sep = ''),
             width= (nrow(subBarcodeAssignedDF[[j]]) * GROUPBY) + 50 ,
             units="mm", limitsize=FALSE)
      
      fileName <- paste(dataPath,"/barcode_filters_",j,".txt",sep = '', collapse = '')
      write.table(barcodeFilterMelted, file = fileName, quote = FALSE, sep = "\t")
      
    }
  
    # Now make the unassigned histograms for each barcode
    for (j in 1:length(UNNASIGNEDFILES)){
      
      # Get the barcode name
      barcode <- strsplit(strsplit(UNNASIGNEDFILES[j], "/", fixed = TRUE)[[1]][length(strsplit(UNNASIGNEDFILES[j], "/", fixed = TRUE)[[1]])], "_", fixed = TRUE)[[1]][1]
      
      # Get the data
      unnasignedDF <- read.table(UNNASIGNEDFILES[j])
    
      # Sort by Total
      unnasignedDF <- unnasignedDF[with(unnasignedDF, order(-Total)), ]
      
      # Get the top 15
      unnasignedDF <- unnasignedDF[1:15,]
      
      # Find out the row ID and add it to the leyend of each column
      baseZero <- nchar(toString(nrow(unnasignedDF)))
      unnasignedDF$ID <- ""
    
      for(p in 1:nrow(unnasignedDF)){
        
        unnasignedDF$ID[p] <- rownames(unnasignedDF[p,])
        
        #Find how many zeros we need to fix the sort
        totalZeros  <- baseZero - nchar(toString(p))
        stringZeros <- paste(rep("0",totalZeros),collapse='')
        
        unnasignedDF$ID[p] <- paste(stringZeros,p,"_*_",toString(unnasignedDF$ID[p]),sep='')
        
      }
    
      # Make the plot and save it
      unnasignedPlot <- ggplot(data=unnasignedDF, aes(x=ID, y=Total), na.rm = TRUE)
      unnasignedPlot <- unnasignedPlot + geom_bar(stat="identity", na.rm = TRUE, fill = "black")          
      unnasignedPlot <- unnasignedPlot + theme(axis.text.x = element_text(angle = 90, hjust = 1),
                                               panel.background = element_rect(fill = PLOTBACK),
                                               panel.grid.major = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.2),
                                               panel.grid.minor = element_line(colour = PLOTGRID, linetype = LINETYPE, size = 0.5),
                                               panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank())
      
      # Save the file into the plot folder
      ggsave(paste(plotPath,"/",barcode,"_unnasigned.",FORMAT ,sep = ''))
    
      fileName <- paste(dataPath,"/",barcode,"_unnasigned.txt",sep = '', collapse = '')
      write.table(unnasignedDF, file = fileName, quote = FALSE, sep = "\t")
    
    }
  
    }

  #-------------------------------------
  # --- HISTOGRAM AND ARCHPLOT FOR EACH
  #-------------------------------------
    {
      
      print("Plotting Archplots")
      
      # Divide the config dataframe into several subset of roughly equal size
      processorsSubDataframes <- divideWork(TOTAL_PROCESSORS, analysisDF)
      
      # Analyze the config file in parallel 
      parallelPackages = c("ggplot2","GenomicRanges", "ggbio", "plyr", "reshape2")
      
      foreach(j=1:TOTAL_PROCESSORS , .packages=parallelPackages) %dopar% {
        
        # Our own developed stuff.
        source("libraries/tools.R") # Minor stuff like the reverse complement of a DNA sequence.
        source("libraries/configPlotting.R") # Function that deals with the config files and get running everything.
        
        makePlots(CUT_RATE, NO_CUT_RATE, NO_DELETION, IN_FRAME, FRAMESHIFT,
                  MULTIPLES, DELETION_COLOR, CUT_COLOR, POSITION_WINDOW, START,
                  END, DUPLICATE_INTO_FOLDERS, PLOTBACK, PLOTGRID, LINETYPE,
                  FREQONE, ACCUMULATE, FILTERENDS, SIZE,
                  processorsSubDataframes[[j]], j, ANALYSIS_PATH, plotPath,
                  dataPath, alignmentDistance, FORMAT)
        
        
      }
    }

    # Clsoe the master log file descriptor
    close(logFileConn)
    
    # Stop the cluster and go home
    stopCluster(cl)
    
    print("Finish!")
    
    print(as.numeric(Sys.time()-currentTime, units = "secs"))
    
    print(paste("Look for your results in",plotPath))
  
}
  

