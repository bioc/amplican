# This function takes a configuration file and generate the alignments.
#
# Parameters:
#
# (string) ALIGN_FOLDER   The path to an alignment folder generated by
#                         ampliCanMaker(). For example:
#
#                           /Home/johndoe/.../CRISPRS/results/run_20150720171327_run11
#
#
# (int) TOTAL_PROCESSORS  Set this to the number of processors you want to use.
#                         You can set it to NULL if you want all that are
#                         available. Default = 1.
#
# (int) ALL_IN_MODE       This variable tells which critiria do we follow to
#                         decide if only one indel, or many indels, or all
#                         indel, or no indel is within range of one, all, or
#                         none alignment position and many combinations; please
#                         check the documentation in cutscriterias.R for
#                         detailed info.
#
#                         The current options are:
#                         1 - means that all cuts must be within reach.
#                         3 - means that at least one cut must be within reach.
#                             This is the default options.
#                         5 - means we don't care about the reach, so
#                             effectively turning this criteria off.
#
# (int) ALIGNMENT_DISTANCE When looking for valid indels, the indels must be
#                          with in the range of the alignment position. The
#                          range is -ALIGNMENT_DISTANCE nucleotides to the left
#                          and + (AP wide + ALIGNMENT_DISTANCE) to the right.
#                          The default value is 5.
#
# (bool) SAME_CUTS        This variable tells if the valid events must be in
#                         the same absolute position in the Forward alignment
#                         and the Reverse alignment. So if a event must be
#                         confirmed by both reads. Sometimes information from
#                         only one read is available. When this happens it
#                         will use only one read, even if this option is set to
#                         TRUE. The default is TRUE.
#
# (bool) PRIMERDIMER      This variable tells if we should try to filter primer
#                         dimers occurences.
#
# (int) DIMERBASE         The legnth of the constant bases that we use to
#                         adjust the primer dimer situation. The closest that
#                         is to 0, the most intolerant that we are with
#                         suspected primer dimers. The default value is 10.
#                         
# (bool) TIMING           You can choose to generate a timing file for
#                         debugging and benchmarking. Default is FALSE.

ampliCanAnalyzer <- function (ALIGNMENT_FOLDER, TOTAL_PROCESSORS = 1,
                              ALL_IN_MODE = 3, ALIGNMENT_DISTANCE = 5,
                              SAME_CUTS = TRUE, PRIMERDIMER = TRUE, 
                              DIMERBASE = 10, TIMING = FALSE){


  ############################################
  #Summons the libraries and get to use functions from there.
  ############################################
  {  
  
  # Making things in parallel
  library(doParallel)
  cl <- makeCluster(TOTAL_PROCESSORS, outfile="") #outfile tells the workers to print on the terminal
  registerDoParallel(cl)
  
  # Our own developed stuff.
  source("libraries/tools.R") # Minor stuff like the reverse complement of a DNA sequence.
  source("libraries/configAnalyze.R") # Function that deals with the config files and get running everything.
  source("libraries/cutscriterias.R") # How deletions are defined.
  
  }
  
  ############################################
  # Algorith starts here
  ############################################
  
  print("START")
  
  # Rename the variable TODO: Rename in all, this come from old header
  TARGET_FOLDER <- ALIGNMENT_FOLDER
  
  # We are going to write the results in the same folder, inside another folder called:
  # Analysis_<analysis variables>_YYYYmmddHHMMSS
  {
    currentTime <- Sys.time()
    timeStamp <-  strftime(currentTime,"%Y%m%d%H%M%S")
    analysisPath <- paste(TARGET_FOLDER, "/Analysis_",ALL_IN_MODE,"_",ALIGNMENT_DISTANCE,"_",
                          SAME_CUTS,"_", PRIMERDIMER,"_", DIMERBASE,"_",timeStamp, sep = '')
    dir.create(file.path(analysisPath), showWarnings = TRUE)
    
    # Inside this folder it will be a file named log where we will write relevant information
    logFileName <- paste(analysisPath, "/AnalysisLog.txt", sep = '')
    logFileConn <- file(logFileName, open="at")
    
    # Write the analysis variables into the log
    writeLines("The analysis was made with the following variables: ", logFileConn)
    writeLines(paste("ALL IN MODE           : ", ALL_IN_MODE), logFileConn)
    writeLines(paste("ALIGNMENT DISTANCE    : ", ALIGNMENT_DISTANCE), logFileConn)
    writeLines(paste("SAME CUTS             : ", SAME_CUTS), logFileConn)
    writeLines(paste("PRIMER DIMER          : ", PRIMERDIMER), logFileConn)
    writeLines(paste("PRIMER DIMER CONSTANT : ", DIMERBASE), logFileConn)
    writeLines("", logFileConn) # Empty line
  }

  # TODO: Pedantic checking.
  # Check out that we have the following:
  # - A folder called *_results
  # - Inside that folder there is a file called config_results.txt
  # - The number of folders inside *_results is the same as the number
  #   of lines in the .txt file (not counting the header)
  {
  
  # Get the result folder
  resultsPath     <- list.files(path = TARGET_FOLDER, pattern="_alignments", full.names = TRUE)
  allPaths        <- NULL
  allFoldersNames <- NULL
  configPath      <- NULL
  
  if(length(resultsPath) > 0){
    # Get the list of folders
    allPaths        <- list.dirs(path = resultsPath, full.names = TRUE,  recursive=FALSE)  
    allFoldersNames <- list.dirs(path = resultsPath, full.names = FALSE, recursive=FALSE)    
    configPath      <- list.files(path = resultsPath, pattern="config_results.txt", full.names = TRUE)
    
  }

  # If something fails, display on screen, write it on the log, and exit
  else{
    
    print("ERROR!: No result path found")
    print("ERROR!: No config .txt found?")
    
  }
  
  }

  # If we have everything, keep going
  if(!is.null(allPaths) && !is.null(allFoldersNames) && !is.null(configPath)){
  
    # Load the config file into a dataframe
    configDF <-  read.table(configPath, header=TRUE, sep="\t")
  
    # Clean up the Dataframe, we don't need most of the columns
    keeps <- c("ID","Barcode", "Forward_Primer","Reverse_Primer", "Genome", "Sum_Is_Sequence")
    configDF <- configDF[keeps]
  
    # Now we divide the work among the diffent processors.
    processorsSubDataframes <- divideWorkBySize(TOTAL_PROCESSORS, configDF,"Sum_Is_Sequence")
  
    # Analyze the config file in parallel 
    foreach(j=1:TOTAL_PROCESSORS , .packages=c()) %dopar% {
    
      source("libraries/cutscriterias.R") # How deletions are defined.
      source("libraries/tools.R") # Minor stuff like the reverse complement of a DNA sequence.
      source("libraries/configAnalyze.R") # Function that deals with the config files and get running everything.
      
      analyzeConfig(ALL_IN_MODE, ALIGNMENT_DISTANCE, SAME_CUTS, PRIMERDIMER, DIMERBASE,
                    BOTHDIMERS, processorsSubDataframes[[j]], analysisPath, j, resultsPath, TIMING)
    
    
    }
  
    # Put all the logs and all the configs toguether
    totalLogs    <- unifyFiles(analysisPath,  "SUBLOG",             "myFinalLog.txt",          FALSE,TRUE,FALSE)
    totalConTime <- unifyFiles(analysisPath,  "configFile_Timing",  "analysisFile_Timing.txt", TRUE, TRUE,FALSE)
    totalConfigs <- unifyFiles(analysisPath,  "configFile_results", "analysis_results.txt",    TRUE,TRUE,FALSE)
  
  }

  # Close the master log file descriptor
  close(logFileConn)
  
  # Stop the cluster and go home
  stopCluster(cl)
  
  print("Finish!")
  print(paste("Look for your results in", analysisPath))

}